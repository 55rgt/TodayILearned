## 함수의 다양한 형태

### 1. 콜백 함수

**함수 이름**은 꼭 붙이지 않아도 되는 선택 사항이다.

이러한 익명 함수의 대표적인 용도가 바로 **콜백 함수**이다.

**콜백 함수**: 코드를 통해 명시적으로 호출하는 함수가 아니라,
개발자는 단지 함수를 등록하고 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수를 말한다.

또한, 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백 함수가 될 수 있다.

ex) 이벤트 핸들러 처리
    → DOM 이벤트가 발생할 경우, 브라우저는 정의된 DOM 이벤트에 해당하는 이벤트 핸들러를 실행시킨다.
    → 만약 이러한 이벤트 핸들러에 콜백 함수가 등록했다면, 콜백 함수는 이벤트가 발생할 때마다 브라우저에 의해 실행되게 된다.
    
```html
<!DOCTYPE html>
<html><body>
<script>
    window.onload = function(){
            
        alert('This is a callback function');
            
    };
</script>

</body></html>
```

### 2. 즉시 실행 함수

함수를 정의함과 동시에 바로 실행하는 함수

```javascript 1.8
(function (name){
        
    console.log('This is a immediate function --> ' + name);
        
})('foo');
```
즉시 실행 함수를 만드는 방법은,

1. 우선 함수 리터럴을 괄호()로 둘러싼다. (함수 이름이 없어도 됨)
2. 그런 다음 함수가 바로 호출될 수 있게 () 괄호 쌍을 추가한다.

즉시 실행 함수는, 같은 함수를 다시 호출할 수 없다.

따라서 즉시 실행 함수의 이러한 특징을 이용한다면 **최초 한 번의 실행만을 필요로 하는 초기화 코드 부분**등에 사용할 수 있다.

또한, 즉시 실행 함수는 jQuery 등의 자바스크립트 라이브러리나 프레임워크 소스들에서 사용된다.

→ 자바스크립트에서는 **함수 유효 범위**를 지원하는데,
기본적으로 자바스크립트는 변수 선언 시에 프로그램 전체에서 접근 가능한 유효 범위를 가진다.

→ 따라서 변수를 함수 스코프 내에 위치시킴으로써 라이브러리 간 이름 충돌 등의 문제를 방지할 수 있다.

### 3. 내부 함수

**내부 함수**: 함수 내부에 정의된 함수

내부 함수는 자바스크립트의 기능을 보다 강력하게 해주는 클로저를 생성하거나
부모 함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용한다.

```javascript 1.8
function parent(){
    var a = 100;
    var b = 200;
        
    function child(){
        var b = 300;
            
        console.log(a);
        console.log(b);
    }
    child();
}

parent();
/*
    100
    300
*/

child();    // Uncaught ReferenceError
```

이것이 가능한 이유는 자바스크립트의 **스코프 체이닝**때문이다.

```javascript 1.8

/** 함수 스코프 외부에서 내부 함수 호출하는 예제 코드 */
function parent(){
        
    var a = 100;
    var child = function(){
        console.log(a);
    }
        
    return child;
}
    

/** 이와 같이 실행이 끝난 parent()와 같은 부모 함수 스코프의 변수를 참조하는 inner()와 같은 함수를 클로저라고 한다. */
var inner = parent();
inner();

```

### 4. 함수를 리턴하는 함수

자바스크립트에서는 함수도 일급 객체이므로 일반 값처럼 함수 자체를 리턴할 수도 있다.

```javascript 1.8


    
var self = function(){
        
    console.log('a');
        
    return function(){
        console.log('b');
    }
}
    
/** 처음 self() 함수가 호출됐을 때는 'a'가 출력된다. 그리고 다시 self 함수 변수에 self() 함수 호출 리턴값으로 내보낸 함수가 저장된다. */        
self = self();      // a
    
/** 두 번째로 self() 함수가 호출됐을 때는 'b'가 출력된다. 즉, 위에서 self() 함수 호출 후에,
* self 함수 변수가 가리키는 함수가 원래 함수에서 리턴 받은 새로운 함수로 변경됐기 때문이다. */
self();             // b
```
